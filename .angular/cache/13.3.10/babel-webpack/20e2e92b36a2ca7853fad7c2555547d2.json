{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Type, TemplateRef, ComponentRef, ChangeDetectorRef, InjectionToken, Injectable, Optional, Directive, Input, ViewContainerRef, Component, ViewChild, EventEmitter, ChangeDetectionStrategy, Output, ContentChildren, Inject, NgModule } from '@angular/core';\nimport * as i2 from '@angular/forms';\nimport { AbstractControl, FormGroup, FormArray, FormControl, Validators } from '@angular/forms';\nimport { isObservable, merge, of, Observable, Subject } from 'rxjs';\nimport { distinctUntilChanged, startWith, debounceTime, filter, switchMap, take, tap, map } from 'rxjs/operators';\nimport * as i2$1 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/platform-browser';\nimport { __rest } from 'tslib';\nconst _c0 = [\"container\"];\n\nfunction FormlyField_ng_template_0_Template(rf, ctx) {}\n\nfunction FormlyGroup_formly_field_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"formly-field\", 1);\n  }\n\n  if (rf & 2) {\n    const f_r1 = ctx.$implicit;\n    i0.ɵɵproperty(\"field\", f_r1);\n  }\n}\n\nconst _c1 = [\"*\"];\nconst _c2 = [\"fieldComponent\"];\n\nfunction disableTreeValidityCall(form, callback) {\n  const _updateTreeValidity = form._updateTreeValidity.bind(form);\n\n  form._updateTreeValidity = () => {};\n\n  callback();\n  form._updateTreeValidity = _updateTreeValidity;\n}\n\nfunction getFieldId(formId, field, index) {\n  if (field.id) {\n    return field.id;\n  }\n\n  let type = field.type;\n\n  if (!type && field.template) {\n    type = 'template';\n  }\n\n  if (type instanceof Type) {\n    type = type.prototype.constructor.name;\n  }\n\n  return [formId, type, field.key, index].join('_');\n}\n\nfunction hasKey(field) {\n  return !isNil(field.key) && field.key !== '';\n}\n\nfunction getKeyPath(field) {\n  var _a;\n\n  if (!hasKey(field)) {\n    return [];\n  }\n  /* We store the keyPath in the field for performance reasons. This function will be called frequently. */\n\n\n  if (((_a = field._keyPath) === null || _a === void 0 ? void 0 : _a.key) !== field.key) {\n    let path = [];\n\n    if (typeof field.key === 'string') {\n      const key = field.key.indexOf('[') === -1 ? field.key : field.key.replace(/\\[(\\w+)\\]/g, '.$1');\n      path = key.indexOf('.') !== -1 ? key.split('.') : [key];\n    } else if (Array.isArray(field.key)) {\n      path = field.key.slice(0);\n    } else {\n      path = [`${field.key}`];\n    }\n\n    defineHiddenProp(field, '_keyPath', {\n      key: field.key,\n      path\n    });\n  }\n\n  return field._keyPath.path.slice(0);\n}\n\nconst FORMLY_VALIDATORS = ['required', 'pattern', 'minLength', 'maxLength', 'min', 'max'];\n\nfunction assignFieldValue(field, value) {\n  let paths = getKeyPath(field);\n\n  if (paths.length === 0) {\n    return;\n  }\n\n  let root = field;\n\n  while (root.parent) {\n    root = root.parent;\n    paths = [...getKeyPath(root), ...paths];\n  }\n\n  if (value === undefined && field.resetOnHide) {\n    const k = paths.pop();\n    const m = paths.reduce((model, path) => model[path] || {}, root.model);\n    delete m[k];\n    return;\n  }\n\n  assignModelValue(root.model, paths, value);\n}\n\nfunction assignModelValue(model, paths, value) {\n  for (let i = 0; i < paths.length - 1; i++) {\n    const path = paths[i];\n\n    if (!model[path] || !isObject(model[path])) {\n      model[path] = /^\\d+$/.test(paths[i + 1]) ? [] : {};\n    }\n\n    model = model[path];\n  }\n\n  model[paths[paths.length - 1]] = clone(value);\n}\n\nfunction getFieldValue(field) {\n  let model = field.parent ? field.parent.model : field.model;\n\n  for (const path of getKeyPath(field)) {\n    if (!model) {\n      return model;\n    }\n\n    model = model[path];\n  }\n\n  return model;\n}\n\nfunction reverseDeepMerge(dest, ...args) {\n  args.forEach(src => {\n    for (const srcArg in src) {\n      if (isNil(dest[srcArg]) || isBlankString(dest[srcArg])) {\n        dest[srcArg] = clone(src[srcArg]);\n      } else if (objAndSameType(dest[srcArg], src[srcArg])) {\n        reverseDeepMerge(dest[srcArg], src[srcArg]);\n      }\n    }\n  });\n  return dest;\n} // check a value is null or undefined\n\n\nfunction isNil(value) {\n  return value == null;\n}\n\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nfunction isBlankString(value) {\n  return value === '';\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nfunction objAndSameType(obj1, obj2) {\n  return isObject(obj1) && isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2) && !(Array.isArray(obj1) || Array.isArray(obj2));\n}\n\nfunction isObject(x) {\n  return x != null && typeof x === 'object';\n}\n\nfunction isPromise(obj) {\n  return !!obj && typeof obj.then === 'function';\n}\n\nfunction clone(value) {\n  if (!isObject(value) || isObservable(value) || value instanceof TemplateRef ||\n  /* instanceof SafeHtmlImpl */\n  value.changingThisBreaksApplicationSecurity || ['RegExp', 'FileList', 'File', 'Blob'].indexOf(value.constructor.name) !== -1) {\n    return value;\n  }\n\n  if (value instanceof Set) {\n    return new Set(value);\n  }\n\n  if (value instanceof Map) {\n    return new Map(value);\n  } // https://github.com/moment/moment/blob/master/moment.js#L252\n\n\n  if (value._isAMomentObject && isFunction(value.clone)) {\n    return value.clone();\n  }\n\n  if (value instanceof AbstractControl) {\n    return null;\n  }\n\n  if (value instanceof Date) {\n    return new Date(value.getTime());\n  }\n\n  if (Array.isArray(value)) {\n    return value.slice(0).map(v => clone(v));\n  } // best way to clone a js object maybe\n  // https://stackoverflow.com/questions/41474986/how-to-clone-a-javascript-es6-class-instance\n\n\n  const proto = Object.getPrototypeOf(value);\n  let c = Object.create(proto);\n  c = Object.setPrototypeOf(c, proto); // need to make a deep copy so we dont use Object.assign\n  // also Object.assign wont copy property descriptor exactly\n\n  return Object.keys(value).reduce((newVal, prop) => {\n    const propDesc = Object.getOwnPropertyDescriptor(value, prop);\n\n    if (propDesc.get) {\n      Object.defineProperty(newVal, prop, propDesc);\n    } else {\n      newVal[prop] = clone(value[prop]);\n    }\n\n    return newVal;\n  }, c);\n}\n\nfunction defineHiddenProp(field, prop, defaultValue) {\n  Object.defineProperty(field, prop, {\n    enumerable: false,\n    writable: true,\n    configurable: true\n  });\n  field[prop] = defaultValue;\n}\n\nfunction observeDeep(source, paths, setFn) {\n  let observers = [];\n\n  const unsubscribe = () => {\n    observers.forEach(observer => observer());\n    observers = [];\n  };\n\n  const observer = observe(source, paths, ({\n    firstChange,\n    currentValue\n  }) => {\n    !firstChange && setFn();\n    unsubscribe();\n\n    if (isObject(currentValue) && currentValue.constructor.name === 'Object') {\n      Object.keys(currentValue).forEach(prop => {\n        observers.push(observeDeep(source, [...paths, prop], setFn));\n      });\n    }\n  });\n  return () => {\n    observer.unsubscribe();\n    unsubscribe();\n  };\n}\n\nfunction observe(o, paths, setFn) {\n  if (!o._observers) {\n    defineHiddenProp(o, '_observers', {});\n  }\n\n  let target = o;\n\n  for (let i = 0; i < paths.length - 1; i++) {\n    if (!target[paths[i]] || !isObject(target[paths[i]])) {\n      target[paths[i]] = /^\\d+$/.test(paths[i + 1]) ? [] : {};\n    }\n\n    target = target[paths[i]];\n  }\n\n  const key = paths[paths.length - 1];\n  const prop = paths.join('.');\n\n  if (!o._observers[prop]) {\n    o._observers[prop] = {\n      value: target[key],\n      onChange: []\n    };\n  }\n\n  const state = o._observers[prop];\n\n  if (target[key] !== state.value) {\n    state.value = target[key];\n  }\n\n  if (state.onChange.indexOf(setFn) === -1) {\n    state.onChange.push(setFn);\n    setFn({\n      currentValue: state.value,\n      firstChange: true\n    });\n\n    if (state.onChange.length >= 1) {\n      const {\n        enumerable\n      } = Object.getOwnPropertyDescriptor(target, key) || {\n        enumerable: true\n      };\n      Object.defineProperty(target, key, {\n        enumerable,\n        configurable: true,\n        get: () => state.value,\n        set: currentValue => {\n          if (currentValue !== state.value) {\n            const previousValue = state.value;\n            state.value = currentValue;\n            state.onChange.forEach(changeFn => changeFn({\n              previousValue,\n              currentValue,\n              firstChange: false\n            }));\n          }\n        }\n      });\n    }\n  }\n\n  return {\n    setValue(value) {\n      state.value = value;\n    },\n\n    unsubscribe() {\n      state.onChange = state.onChange.filter(changeFn => changeFn !== setFn);\n\n      if (state.onChange.length === 0) {\n        delete o._observers[prop];\n      }\n    }\n\n  };\n}\n\nfunction getField(f, key) {\n  key = Array.isArray(key) ? key.join('.') : key;\n\n  if (!f.fieldGroup) {\n    return undefined;\n  }\n\n  for (let i = 0, len = f.fieldGroup.length; i < len; i++) {\n    const c = f.fieldGroup[i];\n    const k = Array.isArray(c.key) ? c.key.join('.') : c.key;\n\n    if (k === key) {\n      return c;\n    }\n\n    if (c.fieldGroup && (isNil(k) || key.indexOf(`${k}.`) === 0)) {\n      const field = getField(c, isNil(k) ? key : key.slice(k.length + 1));\n\n      if (field) {\n        return field;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction markFieldForCheck(field) {\n  var _a;\n\n  (_a = field._componentRefs) === null || _a === void 0 ? void 0 : _a.forEach(ref => {\n    // NOTE: we cannot use ref.changeDetectorRef, see https://github.com/ngx-formly/ngx-formly/issues/2191\n    if (ref instanceof ComponentRef) {\n      const changeDetectorRef = ref.injector.get(ChangeDetectorRef);\n      changeDetectorRef.markForCheck();\n    } else {\n      ref.markForCheck();\n    }\n  });\n}\n/**\n * An InjectionToken for registering additional formly config options (types, wrappers ...).\n */\n\n\nconst FORMLY_CONFIG = new InjectionToken('FORMLY_CONFIG');\n/**\n * Maintains list of formly config options. This can be used to register new field type.\n */\n\nlet FormlyConfig = /*#__PURE__*/(() => {\n  class FormlyConfig {\n    constructor() {\n      this.types = {};\n      this.validators = {};\n      this.wrappers = {};\n      this.messages = {};\n      this.extras = {\n        checkExpressionOn: 'modelChange',\n        lazyRender: true,\n        resetFieldOnHide: true,\n        renderFormlyFieldElement: true,\n\n        showError(field) {\n          var _a, _b, _c, _d;\n\n          return ((_a = field.formControl) === null || _a === void 0 ? void 0 : _a.invalid) && (((_b = field.formControl) === null || _b === void 0 ? void 0 : _b.touched) || ((_c = field.options.parentForm) === null || _c === void 0 ? void 0 : _c.submitted) || !!((_d = field.field.validation) === null || _d === void 0 ? void 0 : _d.show));\n        }\n\n      };\n      this.extensions = {};\n      this.presets = {};\n      this.extensionsByPriority = {};\n    }\n\n    addConfig(config) {\n      if (config.types) {\n        config.types.forEach(type => this.setType(type));\n      }\n\n      if (config.validators) {\n        config.validators.forEach(validator => this.setValidator(validator));\n      }\n\n      if (config.wrappers) {\n        config.wrappers.forEach(wrapper => this.setWrapper(wrapper));\n      }\n\n      if (config.validationMessages) {\n        config.validationMessages.forEach(validation => this.addValidatorMessage(validation.name, validation.message));\n      }\n\n      if (config.extensions) {\n        this.setSortedExtensions(config.extensions);\n      }\n\n      if (config.extras) {\n        this.extras = Object.assign(Object.assign({}, this.extras), config.extras);\n      }\n\n      if (config.presets) {\n        this.presets = Object.assign(Object.assign({}, this.presets), config.presets.reduce((acc, curr) => Object.assign(Object.assign({}, acc), {\n          [curr.name]: curr.config\n        }), {}));\n      }\n    }\n    /**\n     * Allows you to specify a custom type which you can use in your field configuration.\n     * You can pass an object of options, or an array of objects of options.\n     */\n\n\n    setType(options) {\n      if (Array.isArray(options)) {\n        options.forEach(option => this.setType(option));\n      } else {\n        if (!this.types[options.name]) {\n          this.types[options.name] = {\n            name: options.name\n          };\n        }\n\n        ['component', 'extends', 'defaultOptions', 'wrappers'].forEach(prop => {\n          if (options.hasOwnProperty(prop)) {\n            this.types[options.name][prop] = options[prop];\n          }\n        });\n      }\n    }\n\n    getType(name, throwIfNotFound = false) {\n      if (name instanceof Type) {\n        return {\n          component: name,\n          name: name.prototype.constructor.name\n        };\n      }\n\n      if (!this.types[name]) {\n        if (throwIfNotFound) {\n          throw new Error(`[Formly Error] The type \"${name}\" could not be found. Please make sure that is registered through the FormlyModule declaration.`);\n        }\n\n        return null;\n      }\n\n      this.mergeExtendedType(name);\n      return this.types[name];\n    }\n    /** @ignore */\n\n\n    getMergedField(field = {}) {\n      var _a;\n\n      const type = this.getType(field.type);\n\n      if (!type) {\n        return;\n      }\n\n      if (type.defaultOptions) {\n        reverseDeepMerge(field, type.defaultOptions);\n      }\n\n      const extendDefaults = type.extends && this.getType(type.extends).defaultOptions;\n\n      if (extendDefaults) {\n        reverseDeepMerge(field, extendDefaults);\n      }\n\n      if (field === null || field === void 0 ? void 0 : field.optionsTypes) {\n        field.optionsTypes.forEach(option => {\n          const defaultOptions = this.getType(option).defaultOptions;\n\n          if (defaultOptions) {\n            reverseDeepMerge(field, defaultOptions);\n          }\n        });\n      }\n\n      const componentRef = this.resolveFieldTypeRef(field);\n\n      if ((_a = componentRef === null || componentRef === void 0 ? void 0 : componentRef.instance) === null || _a === void 0 ? void 0 : _a.defaultOptions) {\n        reverseDeepMerge(field, componentRef.instance.defaultOptions);\n      }\n\n      if (!field.wrappers && type.wrappers) {\n        field.wrappers = [...type.wrappers];\n      }\n    }\n    /** @ignore @internal */\n\n\n    resolveFieldTypeRef(field = {}) {\n      const type = this.getType(field.type);\n\n      if (!type) {\n        return null;\n      }\n\n      if (!type.component || type._componentRef) {\n        return type._componentRef;\n      }\n\n      const {\n        _viewContainerRef,\n        _injector\n      } = field.options;\n\n      if (!_viewContainerRef || !_injector) {\n        return null;\n      }\n\n      const componentRef = _viewContainerRef.createComponent(type.component, {\n        injector: _injector\n      });\n\n      defineHiddenProp(type, '_componentRef', componentRef);\n\n      try {\n        componentRef.destroy();\n      } catch (e) {\n        console.error(`An error occurred while destroying the Formly component type \"${field.type}\"`, e);\n      }\n\n      return type._componentRef;\n    }\n\n    setWrapper(options) {\n      this.wrappers[options.name] = options;\n\n      if (options.types) {\n        options.types.forEach(type => {\n          this.setTypeWrapper(type, options.name);\n        });\n      }\n    }\n\n    getWrapper(name) {\n      if (name instanceof Type) {\n        return {\n          component: name,\n          name: name.prototype.constructor.name\n        };\n      }\n\n      if (!this.wrappers[name]) {\n        throw new Error(`[Formly Error] The wrapper \"${name}\" could not be found. Please make sure that is registered through the FormlyModule declaration.`);\n      }\n\n      return this.wrappers[name];\n    }\n    /** @ignore */\n\n\n    setTypeWrapper(type, name) {\n      if (!this.types[type]) {\n        this.types[type] = {};\n      }\n\n      if (!this.types[type].wrappers) {\n        this.types[type].wrappers = [];\n      }\n\n      if (this.types[type].wrappers.indexOf(name) === -1) {\n        this.types[type].wrappers.push(name);\n      }\n    }\n\n    setValidator(options) {\n      this.validators[options.name] = options;\n    }\n\n    getValidator(name) {\n      if (!this.validators[name]) {\n        throw new Error(`[Formly Error] The validator \"${name}\" could not be found. Please make sure that is registered through the FormlyModule declaration.`);\n      }\n\n      return this.validators[name];\n    }\n\n    addValidatorMessage(name, message) {\n      this.messages[name] = message;\n\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        const deprecated = {\n          minlength: 'minLength',\n          maxlength: 'maxLength'\n        };\n\n        if (deprecated[name]) {\n          console.warn(`Formly deprecation: passing validation messages key '${name}' is deprecated since v6.0, use '${deprecated[name]}' instead.`);\n          this.messages[deprecated[name]] = message;\n        }\n      }\n    }\n\n    getValidatorMessage(name) {\n      return this.messages[name];\n    }\n\n    setSortedExtensions(extensionOptions) {\n      // insert new extensions, grouped by priority\n      extensionOptions.forEach(extensionOption => {\n        var _a;\n\n        const priority = (_a = extensionOption.priority) !== null && _a !== void 0 ? _a : 1;\n        this.extensionsByPriority[priority] = Object.assign(Object.assign({}, this.extensionsByPriority[priority]), {\n          [extensionOption.name]: extensionOption.extension\n        });\n      }); // flatten extensions object with sorted keys\n\n      this.extensions = Object.keys(this.extensionsByPriority).map(Number).sort((a, b) => a - b).reduce((acc, prio) => Object.assign(Object.assign({}, acc), this.extensionsByPriority[prio]), {});\n    }\n\n    mergeExtendedType(name) {\n      if (!this.types[name].extends) {\n        return;\n      }\n\n      const extendedType = this.getType(this.types[name].extends);\n\n      if (!this.types[name].component) {\n        this.types[name].component = extendedType.component;\n      }\n\n      if (!this.types[name].wrappers) {\n        this.types[name].wrappers = extendedType.wrappers;\n      }\n    }\n\n  }\n\n  FormlyConfig.ɵfac = function FormlyConfig_Factory(t) {\n    return new (t || FormlyConfig)();\n  };\n\n  FormlyConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FormlyConfig,\n    factory: FormlyConfig.ɵfac,\n    providedIn: 'root'\n  });\n  return FormlyConfig;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet FormlyFormBuilder = /*#__PURE__*/(() => {\n  class FormlyFormBuilder {\n    constructor(config, injector, viewContainerRef, parentForm) {\n      this.config = config;\n      this.injector = injector;\n      this.viewContainerRef = viewContainerRef;\n      this.parentForm = parentForm;\n    }\n\n    buildForm(form, fieldGroup = [], model, options) {\n      this.build({\n        fieldGroup,\n        model,\n        form,\n        options\n      });\n    }\n\n    build(field) {\n      if (!this.config.extensions.core) {\n        throw new Error('NgxFormly: missing `forRoot()` call. use `forRoot()` when registering the `FormlyModule`.');\n      }\n\n      if (!field.parent) {\n        this._setOptions(field);\n\n        disableTreeValidityCall(field.form, () => {\n          var _a, _b;\n\n          this._build(field);\n\n          const options = field.options;\n          (_a = options.checkExpressions) === null || _a === void 0 ? void 0 : _a.call(options, field, true);\n          (_b = options.detectChanges) === null || _b === void 0 ? void 0 : _b.call(options, field);\n        });\n      } else {\n        this._build(field);\n      }\n    }\n\n    _build(field) {\n      var _a;\n\n      if (!field) {\n        return;\n      }\n\n      const extensions = Object.values(this.config.extensions);\n      extensions.forEach(extension => {\n        var _a;\n\n        return (_a = extension.prePopulate) === null || _a === void 0 ? void 0 : _a.call(extension, field);\n      });\n      extensions.forEach(extension => {\n        var _a;\n\n        return (_a = extension.onPopulate) === null || _a === void 0 ? void 0 : _a.call(extension, field);\n      });\n      (_a = field.fieldGroup) === null || _a === void 0 ? void 0 : _a.forEach(f => this._build(f));\n      extensions.forEach(extension => {\n        var _a;\n\n        return (_a = extension.postPopulate) === null || _a === void 0 ? void 0 : _a.call(extension, field);\n      });\n    }\n\n    _setOptions(field) {\n      field.form = field.form || new FormGroup({});\n      field.model = field.model || {};\n      field.options = field.options || {};\n      const options = field.options;\n\n      if (!options._viewContainerRef) {\n        defineHiddenProp(options, '_viewContainerRef', this.viewContainerRef);\n      }\n\n      if (!options._injector) {\n        defineHiddenProp(options, '_injector', this.injector);\n      }\n\n      if (!options.build) {\n        options._buildForm = () => {\n          console.warn(`Formly: 'options._buildForm' is deprecated since v6.0, use 'options.build' instead.`);\n          this.build(field);\n        };\n\n        options.build = (f = field) => {\n          this.build(f);\n          return f;\n        };\n      }\n\n      if (!options.parentForm && this.parentForm) {\n        defineHiddenProp(options, 'parentForm', this.parentForm);\n        observe(options, ['parentForm', 'submitted'], ({\n          firstChange\n        }) => {\n          if (!firstChange) {\n            options.checkExpressions(field);\n            options.detectChanges(field);\n          }\n        });\n      }\n    }\n\n  }\n\n  FormlyFormBuilder.ɵfac = function FormlyFormBuilder_Factory(t) {\n    return new (t || FormlyFormBuilder)(i0.ɵɵinject(FormlyConfig), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i0.ViewContainerRef, 8), i0.ɵɵinject(i2.FormGroupDirective, 8));\n  };\n\n  FormlyFormBuilder.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FormlyFormBuilder,\n    factory: FormlyFormBuilder.ɵfac,\n    providedIn: 'root'\n  });\n  return FormlyFormBuilder;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction unregisterControl(field, emitEvent = false) {\n  const control = field.formControl;\n  const fieldIndex = control._fields ? control._fields.indexOf(field) : -1;\n\n  if (fieldIndex !== -1) {\n    control._fields.splice(fieldIndex, 1);\n  }\n\n  const form = control.parent;\n\n  if (!form) {\n    return;\n  }\n\n  const opts = {\n    emitEvent\n  };\n\n  if (form instanceof FormArray) {\n    const key = form.controls.findIndex(c => c === control);\n\n    if (key !== -1) {\n      form.removeAt(key, opts);\n    }\n  } else if (form instanceof FormGroup) {\n    const paths = getKeyPath(field);\n    const key = paths[paths.length - 1];\n\n    if (form.get([key]) === control) {\n      form.removeControl(key, opts);\n    }\n  }\n\n  control.setParent(null);\n}\n\nfunction findControl(field) {\n  var _a;\n\n  if (field.formControl) {\n    return field.formControl;\n  }\n\n  if (field.shareFormControl === false) {\n    return null;\n  }\n\n  return (_a = field.form) === null || _a === void 0 ? void 0 : _a.get(getKeyPath(field));\n}\n\nfunction registerControl(field, control, emitEvent = false) {\n  control = control || field.formControl;\n\n  if (!control._fields) {\n    defineHiddenProp(control, '_fields', []);\n  }\n\n  if (control._fields.indexOf(field) === -1) {\n    control._fields.push(field);\n  }\n\n  if (!field.formControl && control) {\n    defineHiddenProp(field, 'formControl', control);\n    control.setValidators(null);\n    control.setAsyncValidators(null);\n    field.props.disabled = !!field.props.disabled;\n    const disabledObserver = observe(field, ['props', 'disabled'], ({\n      firstChange,\n      currentValue\n    }) => {\n      if (!firstChange) {\n        currentValue ? field.formControl.disable() : field.formControl.enable();\n      }\n    });\n\n    if (control instanceof FormControl) {\n      control.registerOnDisabledChange(disabledObserver.setValue);\n    }\n  }\n\n  if (!field.form || !hasKey(field)) {\n    return;\n  }\n\n  let form = field.form;\n  const paths = getKeyPath(field);\n  const value = getFieldValue(field);\n\n  if (!(isNil(control.value) && isNil(value)) && control.value !== value && control instanceof FormControl) {\n    control.patchValue(value);\n  }\n\n  for (let i = 0; i < paths.length - 1; i++) {\n    const path = paths[i];\n\n    if (!form.get([path])) {\n      form.setControl(path, new FormGroup({}), {\n        emitEvent\n      });\n    }\n\n    form = form.get([path]);\n  }\n\n  const key = paths[paths.length - 1];\n\n  if (!field._hide && form.get([key]) !== control) {\n    form.setControl(key, control, {\n      emitEvent\n    });\n  }\n}\n\nfunction updateValidity(c, onlySelf = false) {\n  const status = c.status;\n  const value = c.value;\n  c.updateValueAndValidity({\n    emitEvent: false,\n    onlySelf\n  });\n\n  if (status !== c.status) {\n    c.statusChanges.emit(c.status);\n  }\n\n  if (value !== c.value) {\n    c.valueChanges.emit(c.value);\n  }\n}\n\nfunction clearControl(form) {\n  form === null || form === void 0 ? true : delete form._fields;\n  form.setValidators(null);\n  form.setAsyncValidators(null);\n\n  if (form instanceof FormGroup || form instanceof FormArray) {\n    Object.values(form.controls).forEach(c => clearControl(c));\n  }\n}\n\nlet FormlyTemplate = /*#__PURE__*/(() => {\n  class FormlyTemplate {\n    constructor(ref) {\n      this.ref = ref;\n    }\n\n    ngOnChanges() {\n      this.name = this.name || 'formly-group';\n    }\n\n  }\n\n  FormlyTemplate.ɵfac = function FormlyTemplate_Factory(t) {\n    return new (t || FormlyTemplate)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  FormlyTemplate.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FormlyTemplate,\n    selectors: [[\"\", \"formlyTemplate\", \"\"]],\n    inputs: {\n      name: [\"formlyTemplate\", \"name\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return FormlyTemplate;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // workarround for https://github.com/angular/angular/issues/43227#issuecomment-904173738\n\n\nlet FormlyFieldTemplates = /*#__PURE__*/(() => {\n  class FormlyFieldTemplates {}\n\n  FormlyFieldTemplates.ɵfac = function FormlyFieldTemplates_Factory(t) {\n    return new (t || FormlyFieldTemplates)();\n  };\n\n  FormlyFieldTemplates.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FormlyFieldTemplates,\n    factory: FormlyFieldTemplates.ɵfac\n  });\n  return FormlyFieldTemplates;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The `<formly-field>` component is used to render the UI widget (layout + type) of a given `field`.\n */\n\n\nlet FormlyField = /*#__PURE__*/(() => {\n  class FormlyField {\n    constructor(config, renderer, _elementRef, hostContainerRef, form) {\n      this.config = config;\n      this.renderer = renderer;\n      this._elementRef = _elementRef;\n      this.hostContainerRef = hostContainerRef;\n      this.form = form;\n      this.hostObservers = [];\n      this.componentRefs = [];\n      this.hooksObservers = [];\n      this.detectFieldBuild = false;\n\n      this.valueChangesUnsubscribe = () => {};\n    }\n\n    get containerRef() {\n      return this.config.extras.renderFormlyFieldElement ? this.viewContainerRef : this.hostContainerRef;\n    }\n\n    get elementRef() {\n      var _a;\n\n      if (this.config.extras.renderFormlyFieldElement) {\n        return this._elementRef;\n      }\n\n      if (((_a = this.componentRefs) === null || _a === void 0 ? void 0 : _a[0]) instanceof ComponentRef) {\n        return this.componentRefs[0].location;\n      }\n\n      return null;\n    }\n\n    ngAfterContentInit() {\n      this.triggerHook('afterContentInit');\n    }\n\n    ngAfterViewInit() {\n      this.triggerHook('afterViewInit');\n    }\n\n    ngDoCheck() {\n      if (this.detectFieldBuild && this.field && this.field.options) {\n        this.render();\n      }\n    }\n\n    ngOnInit() {\n      this.triggerHook('onInit');\n    }\n\n    ngOnChanges(changes) {\n      this.triggerHook('onChanges', changes);\n    }\n\n    ngOnDestroy() {\n      this.resetRefs(this.field);\n      this.hostObservers.forEach(hostObserver => hostObserver.unsubscribe());\n      this.hooksObservers.forEach(unsubscribe => unsubscribe());\n      this.valueChangesUnsubscribe();\n      this.triggerHook('onDestroy');\n    }\n\n    renderField(containerRef, f, wrappers = []) {\n      var _a, _b, _c;\n\n      if (this.containerRef === containerRef) {\n        this.resetRefs(this.field);\n        this.containerRef.clear();\n        wrappers = (_a = this.field) === null || _a === void 0 ? void 0 : _a.wrappers;\n      }\n\n      if ((wrappers === null || wrappers === void 0 ? void 0 : wrappers.length) > 0) {\n        const [wrapper, ...wps] = wrappers;\n        const {\n          component\n        } = this.config.getWrapper(wrapper);\n        const ref = containerRef.createComponent(component);\n        this.attachComponentRef(ref, f);\n        observe(ref.instance, ['fieldComponent'], ({\n          currentValue,\n          previousValue,\n          firstChange\n        }) => {\n          if (currentValue) {\n            if (previousValue && previousValue._lContainer === currentValue._lContainer) {\n              return;\n            }\n\n            const viewRef = previousValue ? previousValue.detach() : null;\n\n            if (viewRef && !viewRef.destroyed) {\n              currentValue.insert(viewRef);\n            } else {\n              this.renderField(currentValue, f, wps);\n            }\n\n            !firstChange && ref.changeDetectorRef.detectChanges();\n          }\n        });\n      } else if (f === null || f === void 0 ? void 0 : f.type) {\n        const inlineType = (_c = (_b = this.form) === null || _b === void 0 ? void 0 : _b.templates) === null || _c === void 0 ? void 0 : _c.find(ref => ref.name === f.type);\n        let ref;\n\n        if (inlineType) {\n          ref = containerRef.createEmbeddedView(inlineType.ref, {\n            $implicit: f\n          });\n        } else {\n          const {\n            component\n          } = this.config.getType(f.type, true);\n          ref = containerRef.createComponent(component);\n        }\n\n        this.attachComponentRef(ref, f);\n      }\n    }\n\n    triggerHook(name, changes) {\n      var _a, _b;\n\n      if (name === 'onInit' || name === 'onChanges' && changes.field && !changes.field.firstChange) {\n        this.valueChangesUnsubscribe = this.fieldChanges(this.field);\n      }\n\n      if ((_b = (_a = this.field) === null || _a === void 0 ? void 0 : _a.hooks) === null || _b === void 0 ? void 0 : _b[name]) {\n        if (!changes || changes.field) {\n          const r = this.field.hooks[name](this.field);\n\n          if (isObservable(r) && ['onInit', 'afterContentInit', 'afterViewInit'].indexOf(name) !== -1) {\n            const sub = r.subscribe();\n            this.hooksObservers.push(() => sub.unsubscribe());\n          }\n        }\n      }\n\n      if (name === 'onChanges' && changes.field) {\n        this.resetRefs(changes.field.previousValue);\n        this.render();\n      }\n    }\n\n    attachComponentRef(ref, field) {\n      this.componentRefs.push(ref);\n\n      field._componentRefs.push(ref);\n\n      if (ref instanceof ComponentRef) {\n        Object.assign(ref.instance, {\n          field\n        });\n      }\n    }\n\n    render() {\n      if (!this.field) {\n        return;\n      } // require Formly build\n\n\n      if (!this.field.options) {\n        this.detectFieldBuild = true;\n        return;\n      }\n\n      this.detectFieldBuild = false;\n      this.hostObservers.forEach(hostObserver => hostObserver.unsubscribe());\n      this.hostObservers = [observe(this.field, ['hide'], ({\n        firstChange,\n        currentValue\n      }) => {\n        const containerRef = this.containerRef;\n\n        if (this.config.extras.lazyRender === false) {\n          firstChange && this.renderField(containerRef, this.field);\n\n          if (!firstChange || firstChange && currentValue) {\n            this.elementRef && this.renderer.setStyle(this.elementRef.nativeElement, 'display', currentValue ? 'none' : '');\n          }\n        } else {\n          if (currentValue) {\n            containerRef.clear();\n\n            if (this.field.className) {\n              this.renderer.removeAttribute(this.elementRef.nativeElement, 'class');\n            }\n          } else {\n            this.renderField(containerRef, this.field);\n\n            if (this.field.className) {\n              this.renderer.setAttribute(this.elementRef.nativeElement, 'class', this.field.className);\n            }\n          }\n        }\n\n        !firstChange && this.field.options.detectChanges(this.field);\n      }), observe(this.field, ['className'], ({\n        firstChange,\n        currentValue\n      }) => {\n        if ((!firstChange || firstChange && currentValue) && (!this.config.extras.lazyRender || this.field.hide !== true)) {\n          this.elementRef && this.renderer.setAttribute(this.elementRef.nativeElement, 'class', currentValue);\n        }\n      }), ...['touched', 'pristine', 'status'].map(prop => observe(this.field, ['formControl', prop], ({\n        firstChange\n      }) => !firstChange && markFieldForCheck(this.field)))];\n    }\n\n    resetRefs(field) {\n      if (field) {\n        if (field._componentRefs) {\n          field._componentRefs = field._componentRefs.filter(ref => this.componentRefs.indexOf(ref) === -1);\n        } else {\n          defineHiddenProp(this.field, '_componentRefs', []);\n        }\n      }\n\n      this.componentRefs = [];\n    }\n\n    fieldChanges(field) {\n      this.valueChangesUnsubscribe();\n\n      if (!field) {\n        return () => {};\n      }\n\n      const subscribes = [observeDeep(field, ['props'], () => field.options.detectChanges(field)), observeDeep(field.options, ['formState'], () => field.options.detectChanges(field))];\n\n      for (const key of Object.keys(field._expressions)) {\n        const expressionObserver = observe(field, ['_expressions', key], ({\n          currentValue,\n          previousValue\n        }) => {\n          if (previousValue === null || previousValue === void 0 ? void 0 : previousValue.subscription) {\n            previousValue.subscription.unsubscribe();\n            previousValue.subscription = null;\n          }\n\n          if (isObservable(currentValue.value$)) {\n            currentValue.subscription = currentValue.value$.subscribe();\n          }\n        });\n        subscribes.push(() => {\n          var _a;\n\n          if ((_a = field._expressions[key]) === null || _a === void 0 ? void 0 : _a.subscription) {\n            field._expressions[key].subscription.unsubscribe();\n          }\n\n          expressionObserver.unsubscribe();\n        });\n      }\n\n      for (const path of [['template'], ['fieldGroupClassName'], ['validation', 'show']]) {\n        const fieldObserver = observe(field, path, ({\n          firstChange\n        }) => !firstChange && field.options.detectChanges(field));\n        subscribes.push(() => fieldObserver.unsubscribe());\n      }\n\n      if (field.formControl && !field.fieldGroup) {\n        const control = field.formControl;\n        let valueChanges = control.valueChanges.pipe(distinctUntilChanged((x, y) => {\n          if (x !== y || Array.isArray(x) || isObject(x)) {\n            return false;\n          }\n\n          return true;\n        }));\n\n        if (control.value !== getFieldValue(field)) {\n          valueChanges = valueChanges.pipe(startWith(control.value));\n        }\n\n        const {\n          updateOn,\n          debounce\n        } = field.modelOptions;\n\n        if ((!updateOn || updateOn === 'change') && (debounce === null || debounce === void 0 ? void 0 : debounce.default) > 0) {\n          valueChanges = control.valueChanges.pipe(debounceTime(debounce.default));\n        }\n\n        const sub = valueChanges.subscribe(value => {\n          var _a, _b; // workaround for https://github.com/angular/angular/issues/13792\n\n\n          if (((_a = control._fields) === null || _a === void 0 ? void 0 : _a.length) > 1 && control instanceof FormControl) {\n            control.patchValue(value, {\n              emitEvent: false,\n              onlySelf: true\n            });\n          }\n\n          (_b = field.parsers) === null || _b === void 0 ? void 0 : _b.forEach(parserFn => value = parserFn(value));\n\n          if (value !== field.formControl.value) {\n            field.formControl.setValue(value);\n            return;\n          }\n\n          if (hasKey(field)) {\n            assignFieldValue(field, value);\n          }\n\n          field.options.fieldChanges.next({\n            value,\n            field,\n            type: 'valueChanges'\n          });\n        });\n        subscribes.push(() => sub.unsubscribe());\n      }\n\n      return () => subscribes.forEach(subscribe => subscribe());\n    }\n\n  }\n\n  FormlyField.ɵfac = function FormlyField_Factory(t) {\n    return new (t || FormlyField)(i0.ɵɵdirectiveInject(FormlyConfig), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(FormlyFieldTemplates, 8));\n  };\n\n  FormlyField.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FormlyField,\n    selectors: [[\"formly-field\"]],\n    viewQuery: function FormlyField_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7, ViewContainerRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewContainerRef = _t.first);\n      }\n    },\n    inputs: {\n      field: \"field\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 0,\n    consts: [[\"container\", \"\"]],\n    template: function FormlyField_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, FormlyField_ng_template_0_Template, 0, 0, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]:empty{display:none}\"]\n  });\n  return FormlyField;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The `<form-form>` component is the main container of the form,\n * which takes care of managing the form state\n * and delegates the rendering of each field to `<formly-field>` component.\n */\n\n\nlet FormlyForm = /*#__PURE__*/(() => {\n  class FormlyForm {\n    constructor(builder, config, ngZone, fieldTemplates) {\n      this.builder = builder;\n      this.config = config;\n      this.ngZone = ngZone;\n      this.fieldTemplates = fieldTemplates;\n      /** Event that is emitted when the model value is changed */\n\n      this.modelChange = new EventEmitter();\n      this.field = {\n        type: 'formly-group'\n      };\n      this._modelChangeValue = {};\n\n      this.valueChangesUnsubscribe = () => {};\n    }\n    /** The form instance which allow to track model value and validation status. */\n\n\n    set form(form) {\n      this.field.form = form;\n    }\n\n    get form() {\n      return this.field.form;\n    }\n    /** The model to be represented by the form. */\n\n\n    set model(model) {\n      this.setField({\n        model\n      });\n    }\n\n    get model() {\n      return this.field.model;\n    }\n    /** The field configurations for building the form. */\n\n\n    set fields(fieldGroup) {\n      this.setField({\n        fieldGroup\n      });\n    }\n\n    get fields() {\n      return this.field.fieldGroup;\n    }\n    /** Options for the form. */\n\n\n    set options(options) {\n      this.setField({\n        options\n      });\n    }\n\n    get options() {\n      return this.field.options;\n    }\n\n    set templates(templates) {\n      this.fieldTemplates.templates = templates;\n    }\n\n    ngDoCheck() {\n      if (this.config.extras.checkExpressionOn === 'changeDetectionCheck') {\n        this.checkExpressionChange();\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (changes.fields && this.form) {\n        clearControl(this.form);\n      }\n\n      if (changes.fields || changes.form || changes.model && this._modelChangeValue !== changes.model.currentValue) {\n        this.valueChangesUnsubscribe();\n        this.builder.build(this.field);\n        this.valueChangesUnsubscribe = this.valueChanges();\n      }\n    }\n\n    ngOnDestroy() {\n      this.valueChangesUnsubscribe();\n    }\n\n    checkExpressionChange() {\n      var _a, _b;\n\n      (_b = (_a = this.field.options).checkExpressions) === null || _b === void 0 ? void 0 : _b.call(_a, this.field);\n    }\n\n    valueChanges() {\n      this.valueChangesUnsubscribe();\n      const sub = this.field.options.fieldChanges.pipe(filter(({\n        field,\n        type\n      }) => hasKey(field) && type === 'valueChanges'), switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1)))).subscribe(() => this.ngZone.runGuarded(() => {\n        // runGuarded is used to keep in sync the expression changes\n        // https://github.com/ngx-formly/ngx-formly/issues/2095\n        this.checkExpressionChange();\n        this.modelChange.emit(this._modelChangeValue = clone(this.model));\n      }));\n      return () => sub.unsubscribe();\n    }\n\n    setField(field) {\n      if (this.config.extras.immutable) {\n        this.field = Object.assign(Object.assign({}, this.field), clone(field));\n      } else {\n        Object.keys(field).forEach(p => this.field[p] = field[p]);\n      }\n    }\n\n  }\n\n  FormlyForm.ɵfac = function FormlyForm_Factory(t) {\n    return new (t || FormlyForm)(i0.ɵɵdirectiveInject(FormlyFormBuilder), i0.ɵɵdirectiveInject(FormlyConfig), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(FormlyFieldTemplates));\n  };\n\n  FormlyForm.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FormlyForm,\n    selectors: [[\"formly-form\"]],\n    contentQueries: function FormlyForm_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FormlyTemplate, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templates = _t);\n      }\n    },\n    inputs: {\n      form: \"form\",\n      model: \"model\",\n      fields: \"fields\",\n      options: \"options\"\n    },\n    outputs: {\n      modelChange: \"modelChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([FormlyFormBuilder, FormlyFieldTemplates]), i0.ɵɵNgOnChangesFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"field\"]],\n    template: function FormlyForm_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"formly-field\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"field\", ctx.field);\n      }\n    },\n    directives: [FormlyField],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return FormlyForm;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Allow to link the `field` HTML attributes (`id`, `name` ...) and Event attributes (`focus`, `blur` ...) to an element in the DOM.\n */\n\n\nlet FormlyAttributes = /*#__PURE__*/(() => {\n  class FormlyAttributes {\n    constructor(renderer, elementRef, _document) {\n      this.renderer = renderer;\n      this.elementRef = elementRef;\n      this.uiAttributesCache = {};\n      /**\n       * HostBinding doesn't register listeners conditionally which may produce some perf issues.\n       *\n       * Formly issue: https://github.com/ngx-formly/ngx-formly/issues/1991\n       */\n\n      this.uiEvents = {\n        listeners: [],\n        events: ['click', 'keyup', 'keydown', 'keypress', 'focus', 'blur', 'change'],\n        callback: (eventName, $event) => {\n          switch (eventName) {\n            case 'focus':\n              return this.onFocus($event);\n\n            case 'blur':\n              return this.onBlur($event);\n\n            case 'change':\n              return this.onChange($event);\n\n            default:\n              return this.props[eventName](this.field, $event);\n          }\n        }\n      };\n      this.document = _document;\n    }\n\n    get props() {\n      return this.field.props || {};\n    }\n\n    get fieldAttrElements() {\n      var _a;\n\n      return ((_a = this.field) === null || _a === void 0 ? void 0 : _a['_elementRefs']) || [];\n    }\n\n    ngOnChanges(changes) {\n      var _a;\n\n      if (changes.field) {\n        this.field.name && this.setAttribute('name', this.field.name);\n        this.uiEvents.listeners.forEach(listener => listener());\n        this.uiEvents.events.forEach(eventName => {\n          var _a;\n\n          if (((_a = this.props) === null || _a === void 0 ? void 0 : _a[eventName]) || ['focus', 'blur', 'change'].indexOf(eventName) !== -1) {\n            this.uiEvents.listeners.push(this.renderer.listen(this.elementRef.nativeElement, eventName, e => this.uiEvents.callback(eventName, e)));\n          }\n        });\n\n        if ((_a = this.props) === null || _a === void 0 ? void 0 : _a.attributes) {\n          observe(this.field, ['props', 'attributes'], ({\n            currentValue,\n            previousValue\n          }) => {\n            if (previousValue) {\n              Object.keys(previousValue).forEach(attr => this.removeAttribute(attr));\n            }\n\n            if (currentValue) {\n              Object.keys(currentValue).forEach(attr => {\n                if (currentValue[attr] != null) {\n                  this.setAttribute(attr, currentValue[attr]);\n                }\n              });\n            }\n          });\n        }\n\n        this.detachElementRef(changes.field.previousValue);\n        this.attachElementRef(changes.field.currentValue);\n\n        if (this.fieldAttrElements.length === 1) {\n          !this.id && this.field.id && this.setAttribute('id', this.field.id);\n          this.focusObserver = observe(this.field, ['focus'], ({\n            currentValue\n          }) => {\n            this.toggleFocus(currentValue);\n          });\n        }\n      }\n\n      if (changes.id) {\n        this.setAttribute('id', this.id);\n      }\n    }\n    /**\n     * We need to re-evaluate all the attributes on every change detection cycle, because\n     * by using a HostBinding we run into certain edge cases. This means that whatever logic\n     * is in here has to be super lean or we risk seriously damaging or destroying the performance.\n     *\n     * Formly issue: https://github.com/ngx-formly/ngx-formly/issues/1317\n     * Material issue: https://github.com/angular/components/issues/14024\n     */\n\n\n    ngDoCheck() {\n      if (!this.uiAttributes) {\n        const element = this.elementRef.nativeElement;\n        this.uiAttributes = [...FORMLY_VALIDATORS, 'tabindex', 'placeholder', 'readonly', 'disabled', 'step'].filter(attr => !element.hasAttribute || !element.hasAttribute(attr));\n      }\n\n      this.uiAttributes.forEach(attr => {\n        const value = this.props[attr];\n\n        if (this.uiAttributesCache[attr] !== value && (!this.props.attributes || !this.props.attributes.hasOwnProperty(attr.toLowerCase()))) {\n          this.uiAttributesCache[attr] = value;\n\n          if (value || value === 0) {\n            this.setAttribute(attr, value === true ? attr : `${value}`);\n          } else {\n            this.removeAttribute(attr);\n          }\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      var _a;\n\n      this.uiEvents.listeners.forEach(listener => listener());\n      this.detachElementRef(this.field);\n      (_a = this.focusObserver) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n\n    toggleFocus(value) {\n      const element = this.fieldAttrElements ? this.fieldAttrElements[0] : null;\n\n      if (!element || !element.nativeElement.focus) {\n        return;\n      }\n\n      const isFocused = !!this.document.activeElement && this.fieldAttrElements.some(({\n        nativeElement\n      }) => this.document.activeElement === nativeElement || nativeElement.contains(this.document.activeElement));\n\n      if (value && !isFocused) {\n        Promise.resolve().then(() => element.nativeElement.focus());\n      } else if (!value && isFocused) {\n        Promise.resolve().then(() => element.nativeElement.blur());\n      }\n    }\n\n    onFocus($event) {\n      var _a, _b, _c;\n\n      (_a = this.focusObserver) === null || _a === void 0 ? void 0 : _a.setValue(true);\n      (_c = (_b = this.props).focus) === null || _c === void 0 ? void 0 : _c.call(_b, this.field, $event);\n    }\n\n    onBlur($event) {\n      var _a, _b, _c;\n\n      (_a = this.focusObserver) === null || _a === void 0 ? void 0 : _a.setValue(false);\n      (_c = (_b = this.props).blur) === null || _c === void 0 ? void 0 : _c.call(_b, this.field, $event);\n    } // handle custom `change` event, for regular ones rely on DOM listener\n\n\n    onHostChange($event) {\n      if ($event instanceof Event) {\n        return;\n      }\n\n      this.onChange($event);\n    }\n\n    onChange($event) {\n      var _a, _b, _c;\n\n      (_b = (_a = this.props).change) === null || _b === void 0 ? void 0 : _b.call(_a, this.field, $event);\n      (_c = this.field.formControl) === null || _c === void 0 ? void 0 : _c.markAsDirty();\n    }\n\n    attachElementRef(f) {\n      var _a;\n\n      if (!f) {\n        return;\n      }\n\n      if (((_a = f['_elementRefs']) === null || _a === void 0 ? void 0 : _a.indexOf(this.elementRef)) === -1) {\n        f['_elementRefs'].push(this.elementRef);\n      } else {\n        defineHiddenProp(f, '_elementRefs', [this.elementRef]);\n      }\n    }\n\n    detachElementRef(f) {\n      const index = (f === null || f === void 0 ? void 0 : f['_elementRefs']) ? this.fieldAttrElements.indexOf(this.elementRef) : -1;\n\n      if (index !== -1) {\n        f['_elementRefs'].splice(index, 1);\n      }\n    }\n\n    setAttribute(attr, value) {\n      this.renderer.setAttribute(this.elementRef.nativeElement, attr, value);\n    }\n\n    removeAttribute(attr) {\n      this.renderer.removeAttribute(this.elementRef.nativeElement, attr);\n    }\n\n  }\n\n  FormlyAttributes.ɵfac = function FormlyAttributes_Factory(t) {\n    return new (t || FormlyAttributes)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  FormlyAttributes.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FormlyAttributes,\n    selectors: [[\"\", \"formlyAttributes\", \"\"]],\n    hostBindings: function FormlyAttributes_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"change\", function FormlyAttributes_change_HostBindingHandler($event) {\n          return ctx.onHostChange($event);\n        });\n      }\n    },\n    inputs: {\n      field: [\"formlyAttributes\", \"field\"],\n      id: \"id\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return FormlyAttributes;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet FieldType = /*#__PURE__*/(() => {\n  class FieldType {\n    get model() {\n      return this.field.model;\n    }\n\n    get form() {\n      return this.field.form;\n    }\n\n    get options() {\n      return this.field.options;\n    }\n\n    get key() {\n      return this.field.key;\n    }\n\n    get formControl() {\n      return this.field.formControl;\n    }\n\n    get props() {\n      return this.field.props || {};\n    }\n    /** @deprecated Use `props` instead. */\n\n\n    get to() {\n      return this.props;\n    }\n\n    get showError() {\n      return this.options.showError(this);\n    }\n\n    get id() {\n      return this.field.id;\n    }\n\n    get formState() {\n      return this.options.formState || {};\n    }\n\n  }\n\n  FieldType.ɵfac = function FieldType_Factory(t) {\n    return new (t || FieldType)();\n  };\n\n  FieldType.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FieldType,\n    inputs: {\n      field: \"field\"\n    }\n  });\n  return FieldType;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @ignore */\n\n\nlet FormlyGroup = /*#__PURE__*/(() => {\n  class FormlyGroup extends FieldType {}\n\n  FormlyGroup.ɵfac = /* @__PURE__ */function () {\n    let ɵFormlyGroup_BaseFactory;\n    return function FormlyGroup_Factory(t) {\n      return (ɵFormlyGroup_BaseFactory || (ɵFormlyGroup_BaseFactory = i0.ɵɵgetInheritedFactory(FormlyGroup)))(t || FormlyGroup);\n    };\n  }();\n\n  FormlyGroup.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FormlyGroup,\n    selectors: [[\"formly-group\"]],\n    hostVars: 2,\n    hostBindings: function FormlyGroup_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.field.fieldGroupClassName || \"\");\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 2,\n    vars: 1,\n    consts: [[3, \"field\", 4, \"ngFor\", \"ngForOf\"], [3, \"field\"]],\n    template: function FormlyGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, FormlyGroup_formly_field_0_Template, 1, 1, \"formly-field\", 0);\n        i0.ɵɵprojection(1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.field.fieldGroup);\n      }\n    },\n    directives: [FormlyField, i2$1.NgForOf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return FormlyGroup;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The `<formly-validation-message>` component renders the error message of a given `field`.\n */\n\n\nlet FormlyValidationMessage = /*#__PURE__*/(() => {\n  class FormlyValidationMessage {\n    constructor(config) {\n      this.config = config;\n    }\n\n    ngOnChanges() {\n      const EXPR_VALIDATORS = FORMLY_VALIDATORS.map(v => `templateOptions.${v}`);\n      this.errorMessage$ = merge(this.field.formControl.statusChanges, !this.field.options ? of(null) : this.field.options.fieldChanges.pipe(filter(({\n        field,\n        type,\n        property\n      }) => {\n        return field === this.field && type === 'expressionChanges' && (property.indexOf('validation') !== -1 || EXPR_VALIDATORS.indexOf(property) !== -1);\n      }))).pipe(startWith(null), switchMap(() => isObservable(this.errorMessage) ? this.errorMessage : of(this.errorMessage)));\n    }\n\n    get errorMessage() {\n      var _a, _b, _c, _d, _e, _f;\n\n      const fieldForm = this.field.formControl;\n\n      for (const error in fieldForm.errors) {\n        if (fieldForm.errors.hasOwnProperty(error)) {\n          let message = this.config.getValidatorMessage(error);\n\n          if (isObject(fieldForm.errors[error])) {\n            if (fieldForm.errors[error].errorPath) {\n              return undefined;\n            }\n\n            if (fieldForm.errors[error].message) {\n              message = fieldForm.errors[error].message;\n            }\n          }\n\n          if ((_b = (_a = this.field.validation) === null || _a === void 0 ? void 0 : _a.messages) === null || _b === void 0 ? void 0 : _b[error]) {\n            message = this.field.validation.messages[error];\n          }\n\n          if ((_d = (_c = this.field.validators) === null || _c === void 0 ? void 0 : _c[error]) === null || _d === void 0 ? void 0 : _d.message) {\n            message = this.field.validators[error].message;\n          }\n\n          if ((_f = (_e = this.field.asyncValidators) === null || _e === void 0 ? void 0 : _e[error]) === null || _f === void 0 ? void 0 : _f.message) {\n            message = this.field.asyncValidators[error].message;\n          }\n\n          if (typeof message === 'function') {\n            return message(fieldForm.errors[error], this.field);\n          }\n\n          return message;\n        }\n      }\n\n      return undefined;\n    }\n\n  }\n\n  FormlyValidationMessage.ɵfac = function FormlyValidationMessage_Factory(t) {\n    return new (t || FormlyValidationMessage)(i0.ɵɵdirectiveInject(FormlyConfig));\n  };\n\n  FormlyValidationMessage.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FormlyValidationMessage,\n    selectors: [[\"formly-validation-message\"]],\n    inputs: {\n      field: \"field\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 3,\n    template: function FormlyValidationMessage_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtext(0);\n        i0.ɵɵpipe(1, \"async\");\n      }\n\n      if (rf & 2) {\n        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(1, 1, ctx.errorMessage$));\n      }\n    },\n    pipes: [i2$1.AsyncPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return FormlyValidationMessage;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet FieldArrayType = /*#__PURE__*/(() => {\n  class FieldArrayType extends FieldType {\n    onPopulate(field) {\n      if (!field.formControl && hasKey(field)) {\n        const control = findControl(field);\n        registerControl(field, control ? control : new FormArray([], {\n          updateOn: field.modelOptions.updateOn\n        }));\n      }\n\n      field.fieldGroup = field.fieldGroup || [];\n      const length = Array.isArray(field.model) ? field.model.length : 0;\n\n      if (field.fieldGroup.length > length) {\n        for (let i = field.fieldGroup.length - 1; i >= length; --i) {\n          unregisterControl(field.fieldGroup[i], true);\n          field.fieldGroup.splice(i, 1);\n        }\n      }\n\n      for (let i = field.fieldGroup.length; i < length; i++) {\n        const f = Object.assign(Object.assign({}, clone(typeof field.fieldArray === 'function' ? field.fieldArray(field) : field.fieldArray)), {\n          key: `${i}`\n        });\n        field.fieldGroup.push(f);\n      }\n    }\n\n    add(i, initialModel, {\n      markAsDirty\n    } = {\n      markAsDirty: true\n    }) {\n      i = i == null ? this.field.fieldGroup.length : i;\n\n      if (!this.model) {\n        assignFieldValue(this.field, []);\n      }\n\n      this.model.splice(i, 0, initialModel ? clone(initialModel) : undefined);\n\n      this._build();\n\n      markAsDirty && this.formControl.markAsDirty();\n    }\n\n    remove(i, {\n      markAsDirty\n    } = {\n      markAsDirty: true\n    }) {\n      this.model.splice(i, 1);\n      const field = this.field.fieldGroup[i];\n      this.field.fieldGroup.splice(i, 1);\n      this.field.fieldGroup.forEach((f, key) => f.key = `${key}`);\n      unregisterControl(field, true);\n\n      this._build();\n\n      markAsDirty && this.formControl.markAsDirty();\n    }\n\n    _build() {\n      var _a;\n\n      const fields = (_a = this.field.formControl._fields) !== null && _a !== void 0 ? _a : [this.field];\n      fields.forEach(f => this.options.build(f));\n      this.options.fieldChanges.next({\n        field: this.field,\n        value: getFieldValue(this.field),\n        type: 'valueChanges'\n      });\n    }\n\n  }\n\n  FieldArrayType.ɵfac = /* @__PURE__ */function () {\n    let ɵFieldArrayType_BaseFactory;\n    return function FieldArrayType_Factory(t) {\n      return (ɵFieldArrayType_BaseFactory || (ɵFieldArrayType_BaseFactory = i0.ɵɵgetInheritedFactory(FieldArrayType)))(t || FieldArrayType);\n    };\n  }();\n\n  FieldArrayType.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FieldArrayType,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return FieldArrayType;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet FieldWrapper = /*#__PURE__*/(() => {\n  class FieldWrapper extends FieldType {\n    set _staticContent(content) {\n      this.fieldComponent = content;\n    }\n\n  }\n\n  FieldWrapper.ɵfac = /* @__PURE__ */function () {\n    let ɵFieldWrapper_BaseFactory;\n    return function FieldWrapper_Factory(t) {\n      return (ɵFieldWrapper_BaseFactory || (ɵFieldWrapper_BaseFactory = i0.ɵɵgetInheritedFactory(FieldWrapper)))(t || FieldWrapper);\n    };\n  }();\n\n  FieldWrapper.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FieldWrapper,\n    viewQuery: function FieldWrapper_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c2, 5, ViewContainerRef);\n        i0.ɵɵviewQuery(_c2, 7, ViewContainerRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fieldComponent = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._staticContent = _t.first);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return FieldWrapper;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @ignore */\n\n\nlet FormlyTemplateType = /*#__PURE__*/(() => {\n  class FormlyTemplateType extends FieldType {\n    constructor(sanitizer) {\n      super();\n      this.sanitizer = sanitizer;\n      this.innerHtml = {};\n    }\n\n    get template() {\n      if (this.field && this.field.template !== this.innerHtml.template) {\n        this.innerHtml = {\n          template: this.field.template,\n          content: this.props.safeHtml ? this.sanitizer.bypassSecurityTrustHtml(this.field.template) : this.field.template\n        };\n      }\n\n      return this.innerHtml.content;\n    }\n\n  }\n\n  FormlyTemplateType.ɵfac = function FormlyTemplateType_Factory(t) {\n    return new (t || FormlyTemplateType)(i0.ɵɵdirectiveInject(i1.DomSanitizer));\n  };\n\n  FormlyTemplateType.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FormlyTemplateType,\n    selectors: [[\"formly-template\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"innerHtml\"]],\n    template: function FormlyTemplateType_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"innerHtml\", ctx.template, i0.ɵɵsanitizeHtml);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return FormlyTemplateType;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction evalStringExpression(expression, argNames) {\n  try {\n    return Function(...argNames, `return ${expression};`);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nfunction evalExpression(expression, thisArg, argVal) {\n  if (typeof expression === 'function') {\n    return expression.apply(thisArg, argVal);\n  } else {\n    return expression ? true : false;\n  }\n}\n\nclass FieldExpressionExtension {\n  onPopulate(field) {\n    if (field._expressions) {\n      return;\n    } // cache built expression\n\n\n    defineHiddenProp(field, '_expressions', {});\n    observe(field, ['hide'], ({\n      currentValue,\n      firstChange\n    }) => {\n      defineHiddenProp(field, '_hide', !!currentValue);\n\n      if (!firstChange || firstChange && currentValue === true) {\n        field.props.hidden = currentValue;\n\n        field.options._hiddenFieldsForCheck.push(field);\n      }\n    });\n\n    if (field.hideExpression) {\n      observe(field, ['hideExpression'], ({\n        currentValue: expr\n      }) => {\n        field._expressions.hide = this.parseExpressions(field, 'hide', typeof expr === 'boolean' ? () => expr : expr);\n      });\n    }\n\n    const evalExpr = (key, expr) => {\n      if (typeof expr === 'string' || isFunction(expr)) {\n        field._expressions[key] = this.parseExpressions(field, key, expr);\n      } else if (expr instanceof Observable) {\n        field._expressions[key] = {\n          value$: expr.pipe(tap(v => {\n            this.evalExpr(field, key, v);\n            field.options.detectChanges(field);\n          }))\n        };\n      }\n    };\n\n    field.expressions = field.expressions || {};\n\n    for (const key of Object.keys(field.expressions)) {\n      observe(field, ['expressions', key], ({\n        currentValue: expr\n      }) => {\n        evalExpr(key, isFunction(expr) ? (...args) => expr(field, args[3]) : expr);\n      });\n    }\n\n    field.expressionProperties = field.expressionProperties || {};\n\n    for (const key of Object.keys(field.expressionProperties)) {\n      observe(field, ['expressionProperties', key], ({\n        currentValue\n      }) => evalExpr(key, currentValue));\n    }\n  }\n\n  postPopulate(field) {\n    if (field.parent) {\n      return;\n    }\n\n    if (!field.options.checkExpressions) {\n      let checkLocked = false;\n\n      field.options.checkExpressions = (f, ignoreCache) => {\n        if (checkLocked) {\n          return;\n        }\n\n        checkLocked = true;\n        const fieldChanged = this.checkExpressions(f, ignoreCache);\n        const options = field.options;\n\n        options._hiddenFieldsForCheck.sort(f => f.hide ? -1 : 1).forEach(f => this.changeHideState(f, f.hide, !ignoreCache));\n\n        options._hiddenFieldsForCheck = [];\n\n        if (fieldChanged) {\n          this.checkExpressions(field);\n\n          if (field.options && field.options.detectChanges) {\n            field.options.detectChanges(field);\n          }\n        }\n\n        checkLocked = false;\n      };\n\n      field.options._checkField = (f, ignoreCache) => {\n        console.warn(`Formly: 'options._checkField' is deprecated since v6.0, use 'options.checkExpressions' instead.`);\n        field.options.checkExpressions(f, ignoreCache);\n      };\n    }\n  }\n\n  parseExpressions(field, path, expr) {\n    let parentExpression;\n\n    if (field.parent && ['hide', 'props.disabled'].includes(path)) {\n      const rootValue = f => {\n        return path === 'hide' ? f.hide : f.props.disabled;\n      };\n\n      parentExpression = () => {\n        let root = field.parent;\n\n        while (root.parent && !rootValue(root)) {\n          root = root.parent;\n        }\n\n        return rootValue(root);\n      };\n    }\n\n    expr = expr || (() => false);\n\n    if (typeof expr === 'string') {\n      expr = evalStringExpression(expr, ['model', 'formState', 'field']);\n    }\n\n    let currentValue;\n    return {\n      callback: ignoreCache => {\n        try {\n          const exprValue = evalExpression(parentExpression ? (...args) => parentExpression(field) || expr(...args) : expr, {\n            field\n          }, [field.model, field.options.formState, field, ignoreCache]);\n\n          if (ignoreCache || currentValue !== exprValue && (!isObject(exprValue) || isObservable(exprValue) || JSON.stringify(exprValue) !== JSON.stringify(currentValue))) {\n            currentValue = exprValue;\n            this.evalExpr(field, path, exprValue);\n            return true;\n          }\n\n          return false;\n        } catch (error) {\n          error.message = `[Formly Error] [Expression \"${path}\"] ${error.message}`;\n          throw error;\n        }\n      }\n    };\n  }\n\n  checkExpressions(field, ignoreCache = false) {\n    var _a, _b, _c;\n\n    if (!field) {\n      return false;\n    }\n\n    let fieldChanged = false;\n\n    if (field._expressions) {\n      for (const key of Object.keys(field._expressions)) {\n        ((_b = (_a = field._expressions[key]).callback) === null || _b === void 0 ? void 0 : _b.call(_a, ignoreCache)) && (fieldChanged = true);\n      }\n    }\n\n    (_c = field.fieldGroup) === null || _c === void 0 ? void 0 : _c.forEach(f => this.checkExpressions(f, ignoreCache) && (fieldChanged = true));\n    return fieldChanged;\n  }\n\n  changeDisabledState(field, value) {\n    if (field.fieldGroup) {\n      field.fieldGroup.filter(f => !f._expressions.hasOwnProperty('props.disabled')).forEach(f => this.changeDisabledState(f, value));\n    }\n\n    if (hasKey(field) && field.props.disabled !== value) {\n      field.props.disabled = value;\n    }\n  }\n\n  changeHideState(field, hide, resetOnHide) {\n    var _a, _b, _c;\n\n    if (field.fieldGroup) {\n      field.fieldGroup.filter(f => !f._expressions.hide).forEach(f => this.changeHideState(f, hide, resetOnHide));\n    }\n\n    if (field.formControl && hasKey(field)) {\n      defineHiddenProp(field, '_hide', !!(hide || field.hide));\n      const c = field.formControl;\n\n      if (((_a = c._fields) === null || _a === void 0 ? void 0 : _a.length) > 1) {\n        updateValidity(c);\n      }\n\n      if (hide === true && (!c._fields || c._fields.every(f => !!f._hide))) {\n        unregisterControl(field, true);\n\n        if (resetOnHide && field.resetOnHide) {\n          assignFieldValue(field, undefined);\n          field.formControl.reset({\n            value: undefined,\n            disabled: field.formControl.disabled\n          });\n          field.options.fieldChanges.next({\n            value: undefined,\n            field,\n            type: 'valueChanges'\n          });\n\n          if (field.fieldGroup && field.formControl instanceof FormArray) {\n            field.fieldGroup.length = 0;\n          }\n        }\n      } else if (hide === false) {\n        if (field.resetOnHide && !isUndefined(field.defaultValue) && isUndefined(getFieldValue(field))) {\n          assignFieldValue(field, field.defaultValue);\n        }\n\n        registerControl(field, undefined, true);\n\n        if (field.resetOnHide && field.fieldArray && ((_b = field.fieldGroup) === null || _b === void 0 ? void 0 : _b.length) !== ((_c = field.model) === null || _c === void 0 ? void 0 : _c.length)) {\n          field.options.build(field);\n        }\n      }\n    }\n\n    if (field.options.fieldChanges) {\n      field.options.fieldChanges.next({\n        field,\n        type: 'hidden',\n        value: hide\n      });\n    }\n  }\n\n  evalExpr(field, prop, value) {\n    try {\n      let target = field;\n\n      const paths = this._evalExpressionPath(field, prop);\n\n      const lastIndex = paths.length - 1;\n\n      for (let i = 0; i < lastIndex; i++) {\n        target = target[paths[i]];\n      }\n\n      target[paths[lastIndex]] = value;\n    } catch (error) {\n      error.message = `[Formly Error] [Expression \"${prop}\"] ${error.message}`;\n      throw error;\n    }\n\n    if (['templateOptions.disabled', 'props.disabled'].includes(prop) && hasKey(field)) {\n      this.changeDisabledState(field, value);\n    }\n\n    if (prop.indexOf('model.') === 0) {\n      const key = prop.replace(/^model\\./, ''),\n            control = (field === null || field === void 0 ? void 0 : field.key) === key ? field.formControl : field.form.get(key);\n\n      if (control && !(isNil(control.value) && isNil(value)) && control.value !== value) {\n        control.patchValue(value);\n      }\n    }\n\n    this.emitExpressionChanges(field, prop, value);\n  }\n\n  emitExpressionChanges(field, property, value) {\n    if (!field.options.fieldChanges) {\n      return;\n    }\n\n    field.options.fieldChanges.next({\n      field,\n      type: 'expressionChanges',\n      property,\n      value\n    });\n  }\n\n  _evalExpressionPath(field, prop) {\n    if (field._expressions[prop] && field._expressions[prop].paths) {\n      return field._expressions[prop].paths;\n    }\n\n    let paths = [];\n\n    if (prop.indexOf('[') === -1) {\n      paths = prop.split('.');\n    } else {\n      prop.split(/[[\\]]{1,2}/) // https://stackoverflow.com/a/20198206\n      .filter(p => p).forEach(path => {\n        const arrayPath = path.match(/['|\"](.*?)['|\"]/);\n\n        if (arrayPath) {\n          paths.push(arrayPath[1]);\n        } else {\n          paths.push(...path.split('.').filter(p => p));\n        }\n      });\n    }\n\n    if (field._expressions[prop]) {\n      field._expressions[prop].paths = paths;\n    }\n\n    return paths;\n  }\n\n}\n\nclass FieldValidationExtension {\n  constructor(config) {\n    this.config = config;\n  }\n\n  onPopulate(field) {\n    this.initFieldValidation(field, 'validators');\n    this.initFieldValidation(field, 'asyncValidators');\n  }\n\n  initFieldValidation(field, type) {\n    const validators = [];\n\n    if (type === 'validators' && !(field.hasOwnProperty('fieldGroup') && !hasKey(field))) {\n      validators.push(this.getPredefinedFieldValidation(field));\n    }\n\n    if (field[type]) {\n      for (const validatorName of Object.keys(field[type])) {\n        validatorName === 'validation' ? validators.push(...field[type].validation.map(v => this.wrapNgValidatorFn(field, v))) : validators.push(this.wrapNgValidatorFn(field, field[type][validatorName], validatorName));\n      }\n    }\n\n    defineHiddenProp(field, '_' + type, validators);\n  }\n\n  getPredefinedFieldValidation(field) {\n    let VALIDATORS = [];\n    FORMLY_VALIDATORS.forEach(opt => observe(field, ['props', opt], ({\n      currentValue,\n      firstChange\n    }) => {\n      VALIDATORS = VALIDATORS.filter(o => o !== opt);\n\n      if (currentValue != null && currentValue !== false) {\n        VALIDATORS.push(opt);\n      }\n\n      if (!firstChange && field.formControl) {\n        updateValidity(field.formControl);\n      }\n    }));\n    return control => {\n      if (VALIDATORS.length === 0) {\n        return null;\n      }\n\n      return Validators.compose(VALIDATORS.map(opt => () => {\n        var _a, _b, _c, _d;\n\n        const value = field.props[opt];\n\n        switch (opt) {\n          case 'required':\n            return Validators.required(control);\n\n          case 'pattern':\n            return Validators.pattern(value)(control);\n\n          case 'minLength':\n            const minLengthResult = Validators.minLength(value)(control);\n            const minLengthKey = this.config.getValidatorMessage('minlength') || ((_b = (_a = field.validation) === null || _a === void 0 ? void 0 : _a.messages) === null || _b === void 0 ? void 0 : _b.minlength) ? 'minlength' : 'minLength';\n            return minLengthResult ? {\n              [minLengthKey]: minLengthResult.minlength\n            } : null;\n\n          case 'maxLength':\n            const maxLengthResult = Validators.maxLength(value)(control);\n            const maxLengthKey = this.config.getValidatorMessage('maxlength') || ((_d = (_c = field.validation) === null || _c === void 0 ? void 0 : _c.messages) === null || _d === void 0 ? void 0 : _d.maxlength) ? 'maxlength' : 'maxLength';\n            return maxLengthResult ? {\n              [maxLengthKey]: maxLengthResult.maxlength\n            } : null;\n\n          case 'min':\n            return Validators.min(value)(control);\n\n          case 'max':\n            return Validators.max(value)(control);\n\n          default:\n            return null;\n        }\n      }))(control);\n    };\n  }\n\n  wrapNgValidatorFn(field, validator, validatorName) {\n    let validatorOption;\n\n    if (typeof validator === 'string') {\n      validatorOption = clone(this.config.getValidator(validator));\n    }\n\n    if (typeof validator === 'object' && validator.name) {\n      validatorOption = clone(this.config.getValidator(validator.name));\n\n      if (validator.options) {\n        validatorOption.options = validator.options;\n      }\n    }\n\n    if (typeof validator === 'object' && validator.expression) {\n      const {\n        expression\n      } = validator,\n            options = __rest(validator, [\"expression\"]);\n\n      validatorOption = {\n        name: validatorName,\n        validation: expression,\n        options: Object.keys(options).length > 0 ? options : null\n      };\n    }\n\n    if (typeof validator === 'function') {\n      validatorOption = {\n        name: validatorName,\n        validation: validator\n      };\n    }\n\n    return control => {\n      const errors = validatorOption.validation(control, field, validatorOption.options);\n\n      if (isPromise(errors)) {\n        return errors.then(v => this.handleAsyncResult(field, validatorName ? !!v : v, validatorOption));\n      }\n\n      if (isObservable(errors)) {\n        return errors.pipe(map(v => this.handleAsyncResult(field, validatorName ? !!v : v, validatorOption)));\n      }\n\n      return this.handleResult(field, validatorName ? !!errors : errors, validatorOption);\n    };\n  }\n\n  handleAsyncResult(field, errors, options) {\n    // workaround for https://github.com/angular/angular/issues/13200\n    field.options.detectChanges(field);\n    return this.handleResult(field, errors, options);\n  }\n\n  handleResult(field, errors, {\n    name,\n    options\n  }) {\n    var _a, _b;\n\n    if (typeof errors === 'boolean') {\n      errors = errors ? null : {\n        [name]: options ? options : true\n      };\n    }\n\n    const ctrl = field.formControl;\n    (_b = (_a = ctrl === null || ctrl === void 0 ? void 0 : ctrl._childrenErrors) === null || _a === void 0 ? void 0 : _a[name]) === null || _b === void 0 ? void 0 : _b.call(_a);\n\n    if (isObject(errors)) {\n      Object.keys(errors).forEach(name => {\n        const errorPath = errors[name].errorPath ? errors[name].errorPath : options === null || options === void 0 ? void 0 : options.errorPath;\n        const childCtrl = errorPath ? field.formControl.get(errorPath) : null;\n\n        if (childCtrl) {\n          const _a = errors[name],\n                {\n            errorPath: _errorPath\n          } = _a,\n                opts = __rest(_a, [\"errorPath\"]);\n\n          childCtrl.setErrors(Object.assign(Object.assign({}, childCtrl.errors || {}), {\n            [name]: opts\n          }));\n          !ctrl._childrenErrors && defineHiddenProp(ctrl, '_childrenErrors', {});\n\n          ctrl._childrenErrors[name] = () => {\n            const _a = childCtrl.errors || {},\n                  _b = name,\n                  _toDelete = _a[_b],\n                  childErrors = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n            childCtrl.setErrors(Object.keys(childErrors).length === 0 ? null : childErrors);\n          };\n        }\n      });\n    }\n\n    return errors;\n  }\n\n}\n\nclass FieldFormExtension {\n  prePopulate(field) {\n    if (!this.root) {\n      this.root = field;\n    }\n\n    if (field.parent) {\n      Object.defineProperty(field, 'form', {\n        get: () => field.parent.formControl,\n        configurable: true\n      });\n    }\n  }\n\n  onPopulate(field) {\n    if (field.hasOwnProperty('fieldGroup') && !hasKey(field)) {\n      defineHiddenProp(field, 'formControl', field.form);\n    } else {\n      this.addFormControl(field);\n    }\n  }\n\n  postPopulate(field) {\n    if (this.root !== field) {\n      return;\n    }\n\n    this.root = null;\n    const markForCheck = this.setValidators(field);\n\n    if (markForCheck && field.parent) {\n      let parent = field.parent;\n\n      while (parent) {\n        if (hasKey(parent) || !parent.parent) {\n          updateValidity(parent.formControl, true);\n        }\n\n        parent = parent.parent;\n      }\n    }\n  }\n\n  addFormControl(field) {\n    let control = findControl(field);\n\n    if (!control) {\n      const controlOptions = {\n        updateOn: field.modelOptions.updateOn\n      };\n\n      if (field.fieldGroup) {\n        control = new FormGroup({}, controlOptions);\n      } else {\n        const value = hasKey(field) ? getFieldValue(field) : field.defaultValue;\n        control = new FormControl({\n          value,\n          disabled: false\n        }, Object.assign(Object.assign({}, controlOptions), {\n          initialValueIsDefault: true\n        }));\n      }\n    }\n\n    registerControl(field, control);\n  }\n\n  setValidators(field, disabled = false) {\n    var _a, _b;\n\n    if (disabled === false && hasKey(field) && ((_a = field.props) === null || _a === void 0 ? void 0 : _a.disabled)) {\n      disabled = true;\n    }\n\n    let markForCheck = false;\n    (_b = field.fieldGroup) === null || _b === void 0 ? void 0 : _b.forEach(f => f && this.setValidators(f, disabled) && (markForCheck = true));\n\n    if (hasKey(field) || !field.parent || !hasKey(field) && !field.fieldGroup) {\n      const {\n        formControl: c\n      } = field;\n\n      if (c) {\n        if (hasKey(field) && c instanceof FormControl) {\n          if (disabled && c.enabled) {\n            c.disable({\n              emitEvent: false,\n              onlySelf: true\n            });\n            markForCheck = true;\n          }\n\n          if (!disabled && c.disabled) {\n            c.enable({\n              emitEvent: false,\n              onlySelf: true\n            });\n            markForCheck = true;\n          }\n        }\n\n        if (null === c.validator || null === c.asyncValidator) {\n          c.setValidators(() => {\n            const v = Validators.compose(this.mergeValidators(field, '_validators'));\n            return v ? v(c) : null;\n          });\n          c.setAsyncValidators(() => {\n            const v = Validators.composeAsync(this.mergeValidators(field, '_asyncValidators'));\n            return v ? v(c) : of(null);\n          });\n          markForCheck = true;\n        }\n\n        if (markForCheck) {\n          updateValidity(c, true); // update validity of `FormGroup` instance created by field with nested key.\n\n          let parent = c.parent;\n\n          for (let i = 1; i < getKeyPath(field).length; i++) {\n            if (parent) {\n              updateValidity(parent, true);\n              parent = parent.parent;\n            }\n          }\n        }\n      }\n    }\n\n    return markForCheck;\n  }\n\n  mergeValidators(field, type) {\n    var _a;\n\n    const validators = [];\n    const c = field.formControl;\n\n    if (((_a = c === null || c === void 0 ? void 0 : c._fields) === null || _a === void 0 ? void 0 : _a.length) > 1) {\n      c._fields.filter(f => !f._hide).forEach(f => validators.push(...f[type]));\n    } else if (field[type]) {\n      validators.push(...field[type]);\n    }\n\n    if (field.fieldGroup) {\n      field.fieldGroup.filter(f => (f === null || f === void 0 ? void 0 : f.fieldGroup) && !hasKey(f)).forEach(f => validators.push(...this.mergeValidators(f, type)));\n    }\n\n    return validators;\n  }\n\n}\n\nclass CoreExtension {\n  constructor(config) {\n    this.config = config;\n    this.formId = 0;\n  }\n\n  prePopulate(field) {\n    var _a, _b;\n\n    const root = field.parent;\n    this.initRootOptions(field);\n    this.initFieldProps(field);\n\n    if (root) {\n      Object.defineProperty(field, 'options', {\n        get: () => root.options,\n        configurable: true\n      });\n      Object.defineProperty(field, 'model', {\n        get: () => hasKey(field) && field.fieldGroup ? getFieldValue(field) : root.model,\n        configurable: true\n      });\n    }\n\n    Object.defineProperty(field, 'get', {\n      value: key => getField(field, key),\n      configurable: true\n    });\n    (_b = (_a = this.getFieldComponentInstance(field)).prePopulate) === null || _b === void 0 ? void 0 : _b.call(_a, field);\n  }\n\n  onPopulate(field) {\n    var _a, _b;\n\n    this.initFieldOptions(field);\n    (_b = (_a = this.getFieldComponentInstance(field)).onPopulate) === null || _b === void 0 ? void 0 : _b.call(_a, field);\n\n    if (field.fieldGroup) {\n      field.fieldGroup.forEach((f, index) => {\n        if (f) {\n          Object.defineProperty(f, 'parent', {\n            get: () => field,\n            configurable: true\n          });\n          Object.defineProperty(f, 'index', {\n            get: () => index,\n            configurable: true\n          });\n        }\n\n        this.formId++;\n      });\n    }\n  }\n\n  postPopulate(field) {\n    var _a, _b;\n\n    (_b = (_a = this.getFieldComponentInstance(field)).postPopulate) === null || _b === void 0 ? void 0 : _b.call(_a, field);\n  }\n\n  initFieldProps(field) {\n    var _a;\n\n    (_a = field.props) !== null && _a !== void 0 ? _a : field.props = field.templateOptions;\n    Object.defineProperty(field, 'templateOptions', {\n      get: () => field.props,\n      set: props => field.props = props,\n      configurable: true\n    });\n  }\n\n  initRootOptions(field) {\n    if (field.parent) {\n      return;\n    }\n\n    const options = field.options;\n    field.options.formState = field.options.formState || {};\n\n    if (!options.showError) {\n      options.showError = this.config.extras.showError;\n    }\n\n    if (!options.fieldChanges) {\n      defineHiddenProp(options, 'fieldChanges', new Subject());\n    }\n\n    if (!options._hiddenFieldsForCheck) {\n      options._hiddenFieldsForCheck = [];\n    }\n\n    options._markForCheck = f => {\n      console.warn(`Formly: 'options._markForCheck' is deprecated since v6.0, use 'options.detectChanges' instead.`);\n      options.detectChanges(f);\n    };\n\n    options.detectChanges = f => {\n      var _a;\n\n      if (f._componentRefs) {\n        f.options.checkExpressions(f);\n        markFieldForCheck(f);\n      }\n\n      (_a = f.fieldGroup) === null || _a === void 0 ? void 0 : _a.forEach(f => f && options.detectChanges(f));\n    };\n\n    options.resetModel = model => {\n      model = clone(model !== null && model !== void 0 ? model : options._initialModel);\n\n      if (field.model) {\n        Object.keys(field.model).forEach(k => delete field.model[k]);\n        Object.assign(field.model, model || {});\n      }\n\n      options.build(field);\n      field.form.reset(field.model);\n\n      if (options.parentForm && options.parentForm.control === field.formControl) {\n        options.parentForm.submitted = false;\n      }\n    };\n\n    options.updateInitialValue = model => options._initialModel = clone(model !== null && model !== void 0 ? model : field.model);\n\n    field.options.updateInitialValue();\n  }\n\n  initFieldOptions(field) {\n    var _a, _b;\n\n    reverseDeepMerge(field, {\n      id: getFieldId(`formly_${this.formId}`, field, field.index),\n      hooks: {},\n      modelOptions: {},\n      validation: {\n        messages: {}\n      },\n      props: !field.type || !hasKey(field) ? {} : {\n        label: '',\n        placeholder: '',\n        disabled: false\n      }\n    });\n\n    if (this.config.extras.resetFieldOnHide && field.resetOnHide !== false) {\n      field.resetOnHide = true;\n    }\n\n    if (field.type !== 'formly-template' && (field.template || ((_a = field.expressions) === null || _a === void 0 ? void 0 : _a.template) || ((_b = field.expressionProperties) === null || _b === void 0 ? void 0 : _b.template))) {\n      field.type = 'formly-template';\n    }\n\n    if (!field.type && field.fieldGroup) {\n      field.type = 'formly-group';\n    }\n\n    if (field.type) {\n      this.config.getMergedField(field);\n    }\n\n    if (hasKey(field) && !isUndefined(field.defaultValue) && isUndefined(getFieldValue(field))) {\n      const isHidden = f => {\n        var _a;\n\n        return f.hide || ((_a = f.expressions) === null || _a === void 0 ? void 0 : _a.hide) || f.hideExpression;\n      };\n\n      let setDefaultValue = !field.resetOnHide || !isHidden(field);\n\n      if (!isHidden(field) && field.resetOnHide) {\n        let parent = field.parent;\n\n        while (parent && !isHidden(parent)) {\n          parent = parent.parent;\n        }\n\n        setDefaultValue = !parent || !isHidden(parent);\n      }\n\n      if (setDefaultValue) {\n        assignFieldValue(field, field.defaultValue);\n      }\n    }\n\n    field.wrappers = field.wrappers || [];\n  }\n\n  getFieldComponentInstance(field) {\n    const componentRefInstance = () => {\n      var _a;\n\n      let componentRef = this.config.resolveFieldTypeRef(field);\n      const fieldComponentRef = (_a = field._componentRefs) === null || _a === void 0 ? void 0 : _a.slice(-1)[0];\n\n      if (fieldComponentRef instanceof ComponentRef && (fieldComponentRef === null || fieldComponentRef === void 0 ? void 0 : fieldComponentRef.componentType) === (componentRef === null || componentRef === void 0 ? void 0 : componentRef.componentType)) {\n        componentRef = fieldComponentRef;\n      }\n\n      return componentRef === null || componentRef === void 0 ? void 0 : componentRef.instance;\n    };\n\n    if (!field._proxyInstance) {\n      defineHiddenProp(field, '_proxyInstance', new Proxy({}, {\n        get: (_, prop) => {\n          var _a;\n\n          return (_a = componentRefInstance()) === null || _a === void 0 ? void 0 : _a[prop];\n        },\n        set: (_, prop, value) => componentRefInstance()[prop] = value\n      }));\n    }\n\n    return field._proxyInstance;\n  }\n\n}\n\nfunction defaultFormlyConfig(config) {\n  return {\n    types: [{\n      name: 'formly-group',\n      component: FormlyGroup\n    }, {\n      name: 'formly-template',\n      component: FormlyTemplateType\n    }],\n    extensions: [{\n      name: 'core',\n      extension: new CoreExtension(config),\n      priority: -250\n    }, {\n      name: 'field-validation',\n      extension: new FieldValidationExtension(config),\n      priority: -200\n    }, {\n      name: 'field-form',\n      extension: new FieldFormExtension(),\n      priority: -150\n    }, {\n      name: 'field-expression',\n      extension: new FieldExpressionExtension(),\n      priority: -100\n    }]\n  };\n}\n\nlet FormlyModule = /*#__PURE__*/(() => {\n  class FormlyModule {\n    constructor(configService, configs = []) {\n      if (!configs) {\n        return;\n      }\n\n      configs.forEach(config => configService.addConfig(config));\n    }\n\n    static forRoot(config = {}) {\n      return {\n        ngModule: FormlyModule,\n        providers: [{\n          provide: FORMLY_CONFIG,\n          multi: true,\n          useFactory: defaultFormlyConfig,\n          deps: [FormlyConfig]\n        }, {\n          provide: FORMLY_CONFIG,\n          useValue: config,\n          multi: true\n        }, FormlyConfig, FormlyFormBuilder]\n      };\n    }\n\n    static forChild(config = {}) {\n      return {\n        ngModule: FormlyModule,\n        providers: [{\n          provide: FORMLY_CONFIG,\n          multi: true,\n          useFactory: defaultFormlyConfig,\n          deps: [FormlyConfig]\n        }, {\n          provide: FORMLY_CONFIG,\n          useValue: config,\n          multi: true\n        }, FormlyFormBuilder]\n      };\n    }\n\n  }\n\n  FormlyModule.ɵfac = function FormlyModule_Factory(t) {\n    return new (t || FormlyModule)(i0.ɵɵinject(FormlyConfig), i0.ɵɵinject(FORMLY_CONFIG, 8));\n  };\n\n  FormlyModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FormlyModule\n  });\n  FormlyModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return FormlyModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { FORMLY_CONFIG, FieldArrayType, FieldType, FieldWrapper, FormlyConfig, FormlyField, FormlyForm, FormlyFormBuilder, FormlyModule, FormlyAttributes as ɵFormlyAttributes, FormlyGroup as ɵFormlyGroup, FormlyTemplate as ɵFormlyTemplate, FormlyValidationMessage as ɵFormlyValidationMessage, clone as ɵclone, defineHiddenProp as ɵdefineHiddenProp, getFieldValue as ɵgetFieldValue, hasKey as ɵhasKey, observe as ɵobserve, reverseDeepMerge as ɵreverseDeepMerge }; //# sourceMappingURL=ngx-formly-core.mjs.map","map":null,"metadata":{},"sourceType":"module"}